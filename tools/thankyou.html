<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thank You</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Playfair+Display:ital,wght@0,400;0,600;1,400&family=Righteous&family=Fredoka+One&family=Pacifico&family=Lobster&family=Dancing+Script:wght@700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #name-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #name-modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: #222;
            padding: 3rem;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            border: 1px solid #444;
            color: white;
            max-width: 90%;
            width: 400px;
        }
        .modal-content h2 {
            margin-top: 0;
            font-weight: 300;
            margin-bottom: 1.5rem;
            font-family: 'Montserrat', sans-serif;
        }
        input {
            padding: 15px;
            font-size: 1.2rem;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            display: block;
            width: 100%;
            box-sizing: border-box;
            outline: none;
            transition: border-color 0.3s;
            font-family: 'Montserrat', sans-serif;
        }
        input:focus {
            border-color: #888;
        }
        button {
            padding: 12px 30px;
            font-size: 1.1rem;
            background: linear-gradient(45deg, #ff3366, #ff6b6b);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600;
            letter-spacing: 1px;
            font-family: 'Montserrat', sans-serif;
            text-transform: uppercase;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 51, 102, 0.4);
        }

        /* Final Content Layer */
        #final-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }
        #final-content.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .neon-name {
            font-family: var(--name-font), 'Montserrat', sans-serif;
            font-weight: 900;
            font-size: clamp(3rem, 10vw, 8rem); /* Responsive font size */
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: default;
            transition: text-shadow 0.3s ease, transform 0.3s ease;
            animation: float 3s ease-in-out infinite;
            text-align: center;
            padding: 0 20px;
        }

        .neon-name:hover {
            transform: scale(1.05);
        }

        .message-container {
            margin-top: 2rem;
            text-align: center;
            color: rgba(255,255,255,0.9);
            animation: fadeInUp 1s ease 0.5s backwards;
            padding: 0 20px;
        }

        .main-msg {
            font-family: 'Playfair Display', serif;
            font-size: clamp(1.2rem, 3vw, 2rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 1px;
        }

        .sub-msg {
            font-family: 'Playfair Display', serif;
            font-size: clamp(0.9rem, 2vw, 1.2rem);
            font-style: italic;
            opacity: 0.7;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="final-content">
        <div id="name-display" class="neon-name">User Name</div>
        <div class="message-container">
            <div class="main-msg">Thank you for your incredible support!</div>
            <div class="sub-msg">We couldn't have done it without you.</div>
        </div>
    </div>

    <div id="name-modal">
        <div class="modal-content">
            <h2>Who is this card for?</h2>
            <input type="text" id="name-input" placeholder="Enter name here..." autocomplete="off">
            <button id="start-btn">Open Card</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        // Responsive Envelope
        let envW, envH;

        // Configuration
        const colors = [
            { main: '#1a0b2e', neon: '#d946ef', stop1: '#2e1065', stop2: '#000000', font: 'Righteous', emoji: 'âœ¨' }, // Deep Purple / Magenta Neon
            { main: '#022c22', neon: '#2dd4bf', stop1: '#115e59', stop2: '#000000', font: 'Fredoka One', emoji: 'ðŸŒŸ' }, // Deep Teal / Cyan Neon
            { main: '#1e1b4b', neon: '#818cf8', stop1: '#312e81', stop2: '#000000', font: 'Pacifico', emoji: 'ðŸ¥³' }, // Indigo / Blue Neon
            { main: '#450a0a', neon: '#f87171', stop1: '#7f1d1d', stop2: '#000000', font: 'Lobster', emoji: 'ðŸ¥°' }, // Deep Red / Red Neon
            { main: '#422006', neon: '#facc15', stop1: '#713f12', stop2: '#000000', font: 'Dancing Script', emoji: 'ðŸŒž' }  // Deep Amber / Gold Neon
        ];

        // Check for theme parameter (secret feature)
        const urlParams = new URLSearchParams(window.location.search);
        const themeEmoji = urlParams.get('theme');
        
        let selectedColor = colors.find(c => c.emoji === themeEmoji) || colors[Math.floor(Math.random() * colors.length)];
        let userName = '';

        // Apply neon color and font to CSS
        document.documentElement.style.setProperty('--neon-color', selectedColor.neon);
        document.documentElement.style.setProperty('--name-font', selectedColor.font);
        
        // Animation State
        let state = 'init'; 
        let animStart = 0;
        let envX, envY;
        
        // Particle System
        let particles = [];
        let emojiPoints = [];
        
        // Mouse State
        let mouseX = 0;
        let mouseY = 0;
        let lastMouseMoveTime = 0;
        
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            lastMouseMoveTime = performance.now();
            if (lastSpawnX === 0 && lastSpawnY === 0) {
                lastSpawnX = mouseX;
                lastSpawnY = mouseY;
            }
        });

        function createEmojiPoints(emoji) {
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');
            offCanvas.width = 100;
            offCanvas.height = 100;
            
            offCtx.font = '80px serif';
            offCtx.textAlign = 'center';
            offCtx.textBaseline = 'middle';
            offCtx.fillText(emoji, 50, 50);
            
            const imageData = offCtx.getImageData(0, 0, 100, 100);
            const data = imageData.data;
            const points = [];
            
            for (let y = 0; y < 100; y += 2) {
                for (let x = 0; x < 100; x += 2) {
                    const i = (y * 100 + x) * 4;
                    if (data[i + 3] > 128) {
                        points.push({
                            x: x - 50,
                            y: y - 50,
                            color: `rgba(${data[i]}, ${data[i+1]}, ${data[i+2]}, ${data[i+3]/255})`
                        });
                    }
                }
            }
            return points;
        }

        class ParticleEmoji {
            constructor(x, y, duration, scale) {
                this.spawnTime = performance.now();
                this.isFlair = (x !== undefined); // Flag if it's a flair
                
                if (this.isFlair) {
                    this.x = x;
                    this.y = y;
                    this.duration = duration || 1000;
                    this.scale = scale || 0.3;
                    this.opacity = 1;
                    this.floatPhase = Math.random() * Math.PI * 2;
                    this.floatSpeed = 0.002;
                    this.initParticles();
                } else {
                    this.spawn(this.spawnTime);
                }
            }

            spawn(now) {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.scale = 0.4 + Math.random() * 0.4;
                this.spawnTime = now + Math.random() * 2000; // Random delay start
                this.duration = 3000 + Math.random() * 3000; // 3-6s duration
                
                // Global float parameters for the whole emoji
                this.floatPhase = Math.random() * Math.PI * 2;
                this.floatSpeed = 0.001 + Math.random() * 0.001;
                
                this.initParticles();
            }

            initParticles() {
                this.particles = [];
                emojiPoints.forEach(pt => {
                    this.particles.push({
                        x: pt.x * this.scale,
                        y: pt.y * this.scale,
                        color: pt.color
                    });
                });
            }
            
            update(now) {
                let age = now - this.spawnTime;
                
                if (this.isFlair) {
                    if (age > this.duration) return false; // Dead
                    this.opacity = 1 - (age / this.duration); // Linear fade out
                } else {
                    // Background logic
                    if (age < 0) return true; 
                    if (age > this.duration) {
                        this.spawn(now); 
                        return true;
                    }
                    // Fade logic for background
                    if (age < 1000) this.opacity = age / 1000;
                    else if (age > this.duration - 1000) this.opacity = (this.duration - age) / 1000;
                    else this.opacity = 1;
                }

                // Move the whole emoji gently
                this.currentY = this.y + Math.sin(now * this.floatSpeed + this.floatPhase) * 20;
                this.currentX = this.x + Math.cos(now * this.floatSpeed * 0.7 + this.floatPhase) * 10;
                
                return true; // Alive
            }
            
            draw(ctx) {
                if (this.opacity <= 0) return;
                
                ctx.save();
                ctx.translate(this.currentX, this.currentY);
                ctx.globalAlpha = this.opacity;
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    // Draw slightly larger pixels for better coverage
                    ctx.fillRect(p.x, p.y, 2.2 * this.scale, 2.2 * this.scale);
                });
                ctx.restore();
            }
        }

        let floatingEmojis = [];
        let flairEmojis = [];
        let lastFlairSpawn = 0;
        let lastSpawnX = 0;
        let lastSpawnY = 0;

        function initParticles() {
            emojiPoints = createEmojiPoints(selectedColor.emoji);
            // Create 15 floating emojis at random positions
            for(let i=0; i<15; i++) {
                floatingEmojis.push(new ParticleEmoji());
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            // Calculate envelope size based on viewport
            // Max width 600, Min width 280
            // Ideally 40% of screen width or 50% of screen height
            let size = Math.min(width * 0.8, height * 0.6, 600);
            envW = Math.max(size, 280);
            envH = envW * 0.66; // 3:2 aspect ratio
            
            // If animation is finished, redraw background
            if (state === 'final') {
                // We don't just draw background anymore, we let the loop handle it
            }
        }
        window.addEventListener('resize', resize);
        resize();

        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        }

        function init() {
            const nameParam = getUrlParameter('name');
            if (nameParam) {
                userName = nameParam;
                startAnimation();
            } else {
                const modal = document.getElementById('name-modal');
                modal.classList.add('visible');
                
                const start = () => {
                    const input = document.getElementById('name-input');
                    if (input.value.trim()) {
                        userName = input.value.trim();
                        const newUrl = window.location.protocol + "//" + window.location.host + window.location.pathname + '?name=' + encodeURIComponent(userName);
                        window.history.pushState({path:newUrl},'',newUrl);
                        modal.classList.remove('visible');
                        setTimeout(startAnimation, 500);
                    }
                };

                document.getElementById('start-btn').addEventListener('click', start);
                document.getElementById('name-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') start();
                });
                document.getElementById('name-input').focus();
            }
        }

        function startAnimation() {
            state = 'envelope';
            animStart = performance.now();
            
            // Setup DOM elements for final state
            const nameDisplay = document.getElementById('name-display');
            nameDisplay.textContent = userName;
            
            // Initialize Particles
            initParticles();

            // Dynamic Shadow for Neon Effect
            const neonColor = selectedColor.neon;
            const style = document.createElement('style');
            style.innerHTML = `
                .neon-name {
                    text-shadow: 
                        0 0 10px ${neonColor},
                        0 0 20px ${neonColor},
                        0 0 40px ${neonColor},
                        0 0 80px ${neonColor};
                }
                .neon-name:hover {
                    text-shadow: 
                        0 0 10px #fff,
                        0 0 20px ${neonColor},
                        0 0 40px ${neonColor},
                        0 0 80px ${neonColor},
                        0 0 120px ${neonColor},
                        0 0 150px ${neonColor};
                }
            `;
            document.head.appendChild(style);

            requestAnimationFrame(loop);
        }

        function drawEnvelope(openProgress) {
            envX = width / 2 - envW / 2;
            envY = height / 2 - envH / 2;

            // Envelope Body (Back)
            ctx.fillStyle = '#e0e0e0';
            ctx.fillRect(envX, envY, envW, envH);

            // Flap (Back/Inside)
            ctx.beginPath();
            ctx.moveTo(envX, envY);
            ctx.lineTo(envX + envW / 2, envY + envH / 2 - (envH * 0.1));
            ctx.lineTo(envX + envW, envY);
            ctx.fillStyle = '#ccc';
            ctx.fill();

            // Bottom folds
            ctx.beginPath();
            ctx.moveTo(envX, envY + envH);
            ctx.lineTo(envX + envW / 2, envY + envH / 2);
            ctx.lineTo(envX + envW, envY + envH);
            ctx.fillStyle = '#d6d6d6';
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(envX, envY);
            ctx.lineTo(envX + envW / 2, envY + envH / 2);
            ctx.lineTo(envX, envY + envH);
            ctx.fillStyle = '#f5f5f5';
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(envX + envW, envY);
            ctx.lineTo(envX + envW / 2, envY + envH / 2);
            ctx.lineTo(envX + envW, envY + envH);
            ctx.fillStyle = '#f5f5f5';
            ctx.fill();

            // Top Flap Animation
            ctx.save();
            ctx.translate(envX, envY);
            
            ctx.beginPath();
            if (openProgress < 0.5) {
                // Closed to half open
                let yTip = (envH / 2) * (1 - openProgress * 2);
                ctx.moveTo(0, 0);
                ctx.lineTo(envW / 2, yTip);
                ctx.lineTo(envW, 0);
            } else {
                // Half open to fully open
                let yTip = -(envH / 2) * ((openProgress - 0.5) * 2);
                ctx.moveTo(0, 0);
                ctx.lineTo(envW / 2, yTip);
                ctx.lineTo(envW, 0);
            }
            
            ctx.fillStyle = '#e6e6e6';
            ctx.shadowColor = 'rgba(0,0,0,0.2)';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.restore();
        }

        function drawSheetOut(progress) {
            envX = width / 2 - envW / 2;
            envY = height / 2 - envH / 2;

            // Draw open flap (background)
            ctx.beginPath();
            ctx.moveTo(envX, envY);
            ctx.lineTo(envX + envW / 2, envY - envH / 2);
            ctx.lineTo(envX + envW, envY);
            ctx.fillStyle = '#ccc'; 
            ctx.fill();

            // Draw Sheet
            let sheetW = envW * 0.9;
            let sheetH = envH * 0.9;
            let maxRise = envH * 0.8;
            let currentRise = maxRise * progress;
            
            let sheetX = envX + (envW - sheetW) / 2;
            let sheetY = envY + (envH - sheetH) / 2 - currentRise;

            ctx.fillStyle = '#fff';
            ctx.fillRect(sheetX, sheetY, sheetW, sheetH);

            // Draw Envelope Front (Bottom/Sides) to cover bottom of sheet
            // Left
            ctx.beginPath();
            ctx.moveTo(envX, envY);
            ctx.lineTo(envX + envW / 2, envY + envH / 2);
            ctx.lineTo(envX, envY + envH);
            ctx.fillStyle = '#f5f5f5';
            ctx.fill();
            // Right
            ctx.beginPath();
            ctx.moveTo(envX + envW, envY);
            ctx.lineTo(envX + envW / 2, envY + envH / 2);
            ctx.lineTo(envX + envW, envY + envH);
            ctx.fillStyle = '#f5f5f5';
            ctx.fill();
            // Bottom
            ctx.beginPath();
            ctx.moveTo(envX, envY + envH);
            ctx.lineTo(envX + envW / 2, envY + envH / 2);
            ctx.lineTo(envX + envW, envY + envH);
            ctx.fillStyle = '#d6d6d6';
            ctx.fill();
        }

        function drawExpandingSheet(progress) {
            // Start from sheet position and expand to full screen
            let startW = envW * 0.9;
            let startH = envH * 0.9;
            let startX = (width / 2 - envW / 2) + (envW - startW) / 2;
            let startY = (height / 2 - envH / 2) + (envH - startH) / 2 - (envH * 0.8);

            // Target: Full Screen
            let currentW = startW + (width - startW) * progress;
            let currentH = startH + (height - startH) * progress;
            let currentX = startX + (0 - startX) * progress;
            let currentY = startY + (0 - startY) * progress;

            // Draw Rect
            ctx.fillStyle = '#fff';
            ctx.fillRect(currentX, currentY, currentW, currentH);

            // Draw Gradient Overlay
            if (progress > 0.1) {
                let gradOpacity = (progress - 0.1) / 0.9;
                let gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height));
                gradient.addColorStop(0, selectedColor.stop1); 
                gradient.addColorStop(0.6, selectedColor.stop2); // Start darkening earlier
                gradient.addColorStop(1, selectedColor.stop2); 
                
                ctx.globalAlpha = gradOpacity;
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 1.0;
            }
        }

        function drawFinalState(now) {
            // Background
            let gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height));
            gradient.addColorStop(0, selectedColor.stop1);
            gradient.addColorStop(0.6, selectedColor.stop2); // Start darkening earlier
            gradient.addColorStop(1, selectedColor.stop2);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Draw Floating Emojis (Background)
            floatingEmojis.forEach(emoji => {
                emoji.update(now);
                emoji.draw(ctx);
            });

            // Handle Flair
            if (now - lastMouseMoveTime < 1000) {
                // Calculate distance from last spawn
                let dx = mouseX - lastSpawnX;
                let dy = mouseY - lastSpawnY;
                let dist = Math.sqrt(dx*dx + dy*dy);

                // Spawn based on distance (speed dependent)
                // The faster the mouse moves, the more frequently this threshold is crossed
                if (dist > 30) { 
                    let count = Math.floor(dist / 30);
                    for (let i = 1; i <= count; i++) {
                        let t = i / count;
                        let spawnX = lastSpawnX + dx * t;
                        let spawnY = lastSpawnY + dy * t;
                        flairEmojis.push(new ParticleEmoji(spawnX, spawnY, 800, 0.2));
                    }
                    lastSpawnX = mouseX;
                    lastSpawnY = mouseY;
                }
            }

            // Update and Draw Flair
            for (let i = flairEmojis.length - 1; i >= 0; i--) {
                let alive = flairEmojis[i].update(now);
                if (!alive) {
                    flairEmojis.splice(i, 1);
                } else {
                    flairEmojis[i].draw(ctx);
                }
            }
        }

        function loop(now) {
            // Always clear if we are animating particles
            if (state === 'final') {
                drawFinalState(now);
                document.getElementById('final-content').classList.add('visible');
                requestAnimationFrame(loop);
                return; 
            }

            ctx.clearRect(0, 0, width, height);

            if (state === 'envelope') {
                drawEnvelope(0);
                if (now - animStart > 1000) {
                    state = 'opening';
                    animStart = now;
                }
            } else if (state === 'opening') {
                let progress = (now - animStart) / 800;
                if (progress > 1) progress = 1;
                drawEnvelope(progress);
                if (progress === 1) {
                    state = 'sheet-out';
                    animStart = now;
                }
            } else if (state === 'sheet-out') {
                let progress = (now - animStart) / 1000;
                if (progress > 1) progress = 1;
                drawSheetOut(progress);
                if (progress === 1) {
                    state = 'expanding';
                    animStart = now;
                }
            } else if (state === 'expanding') {
                let progress = (now - animStart) / 1500;
                // Ease out
                progress = 1 - Math.pow(1 - progress, 3);
                
                if (progress > 1) progress = 1;
                drawExpandingSheet(progress);
                if (progress >= 0.99) {
                    state = 'final';
                }
            }

            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>
</html>
